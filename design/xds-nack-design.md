# xDS Nack Design

Status: Draft

## Abstract
One to two sentences that describes the goal of this proposal and the problem being solved by the proposed change.
The reader should be able to tell by the title, and the opening paragraph, if this document is relevant to them.

## Background
One to two paragraphs of exposition to set the context for this proposal.

## Goals
- A short list of things which will be accomplished by implementing this proposal.
- Two things is ok.
- Three is pushing it.
- More than three goals suggests that the proposal's scope is too large.

## Non Goals
- A short list of items which are:
- a. out of scope
- b. follow on items which are deliberately excluded from this proposal.

## High-Level Design
One to two paragraphs that describe the high level changes that will be made to implement this proposal.

## Detailed Design

### What NACK responses to do programmed Envoy configuration now
- Scenario with a `RouteConfiguration` that is NACKed
- Scenario setup (in sequential order):
  - Program valid HTTPProxy
  - Program HTTPProxy that leads to configuration that is NACKed (in contrived case, used cookie rewrite configuration and made a bug in Contour generated Lua)
    - This HTTPProxy has 2 routes, one with cookie rewrite (that would lead to NACK) and another that does not (wouldn't be NACKed if alone)
  - Program another valid HTTPProxy
- What actually happens:
  - When all routes are set up with TLS HTTPProxies:
    - 2 valid HTTPProxies are programmed as expected, requests to their endpoints succeed even before/after all 3 resources programmed
    - For NACKed HTTPProxy, *both routes* are thrown out of Envoy config, the whole `RouteConfiguration` resource is deemed invalid since both routes are contained under a single named resource this is an issue (e.g. in test named resource `https/nack.projectcontour.io`)
  - When all routes are set up plain HTTP:
    - Only the resource programmed *before* the invalid/NACKed HTTPProxy is programmed in Envoy
    - All plain HTTP routes are organized under the `ingress_http` `RouteConfiguration` resource so any new updates are thrown out that include invalid config
    - Given we are using xDS SOTW this makes sense
    - Though would still happen with go-control-plane Delta xDS *unless* we remove the invalid config from the snapshot we generate, otherwise the delta generated by go-control-plane would contain the invalid configuration
    - This is a lot harder to debug since everything organized under one Envoy resource, unless we know what k8s resource/dag change happened to cause NACK, we don't know what route/resource to say is invalid
      - Think startup here, if Contour starts with resources that get NACKed, how do we fix that?
      - Can't expect to "find" the resource that is invalid by selectively applying changes, would drop traffic

### Ideas
- In cache, for each resource that could generate a NACK, keep copy of:
  - current generation
  - last "good" generation to roll back to
  - 
- I don't think you need this for endpoints etc. so that can simplify things the set of things that we need this mechanism for
- can build in using the correct generation of a resource into catch fetch operations
- makes it so using controller-runtime cache is harder to acheive
- event handler changes:
  - onUpdate method needs to save the update somehow so we can know what an individual update was
  - add or update
  - snapshot handler needs to have some version coordination with xds server

### Expected UX
- when a k8s resource is updated with config that is NACKed, user is notified
  - status set on objects that have it
  - Contour logs with which resource is nacked, error details if possible
  - possibly add detail to an annotation for objects w/o status (Ingress)
- Contour will keep the Envoy configuration for the previous generation of that object (or none if it is a new object)
- updates to *other* k8s resources are applied to Envoy configuration
- when resource is "fixed" Envoy configuration is updated
- If Contour starts up and there is an object who generates a NACKed configuration, it will exclude that object (treat it as a new object)
  - *This case is a little interesting, since we can't fetch an older generation of an object unless we cached it*

### General Flow
- We need to keep track of each "operation" seen by the event handler and record if it is NACKed or ACKed
  - Resources being added
  - Resources being removed
  - Resources being updated (we have the before and after)
  - Right now operations are used to modify cache, which calculates whether we need a dag rebuild and then dropped
- Associate each operation with a snapshot and save it since a snapshot is generated for each resource change that is relevant to the dag
  - e.g. pseudocode: map[Version]Operation
  - Added to on each dag cache change/snapshot generation
  - *What do we do on startup*
- When we get a NACK
  - xDS Request will include nonce of previous xDS Response the NACK is for
  - also includes last "good" resource/snapshot version
- When we get an ACK, we can remove the operation


### Current implementation

Contour xDS Server:
- 

go-control-plane xDS Server:
- 

## Alternatives Considered
If there are alternative high level or detailed designs that were not pursued they should be called out here with a brief explanation of why they were not pursued.

## Security Considerations
If this proposal has an impact to the security of the product, its users, or data stored or transmitted via the product, they must be addressed here.

## Compatibility
A discussion of any compatibility issues that need to be considered

## Implementation
A description of the implementation, timelines, and any resources that have agreed to contribute.

## Open Issues
A discussion of issues relating to this proposal for which the author does not know the solution. This section may be omitted if there are none.
