// Copyright Project Contour Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package xdscache

import (
	"math"
	"reflect"
	"strconv"
	"sync"

	envoy_types "github.com/envoyproxy/go-control-plane/pkg/cache/types"
	envoy_resource_v3 "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	"github.com/projectcontour/contour/internal/contour"
	"github.com/projectcontour/contour/internal/dag"
	"github.com/sirupsen/logrus"
)

type Snapshotter interface {
	Generate(version string, resources map[envoy_resource_v3.Type][]envoy_types.Resource) error
}

// SnapshotHandler implements the xDS snapshot cache
// by responding to the OnChange() event causing a new
// snapshot to be created.
type SnapshotHandler struct {
	// resources holds the cache of xDS contents.
	resources map[envoy_resource_v3.Type]ResourceCache

	// snapshotVersion holds the current version of the snapshot.
	snapshotVersion int64

	snapshotters []Snapshotter
	snapLock     sync.Mutex

	logrus.FieldLogger

	opLock sync.Mutex
	// snapshot version to op
	changes map[string]change
	// typeurl to response nonce to version
	nonceToVersion map[string]map[string]string

	EventHandler *contour.EventHandler
}

type change struct {
	op dag.CacheOp
	// record of what resource streams acked this change
	acks map[string]bool
}

// NewSnapshotHandler returns an instance of SnapshotHandler.
func NewSnapshotHandler(resources []ResourceCache, logger logrus.FieldLogger) *SnapshotHandler {
	nonceToVersion := map[string]map[string]string{
		envoy_resource_v3.EndpointType: make(map[string]string),
		envoy_resource_v3.ClusterType:  make(map[string]string),
		envoy_resource_v3.RouteType:    make(map[string]string),
		envoy_resource_v3.ListenerType: make(map[string]string),
		envoy_resource_v3.SecretType:   make(map[string]string),
		envoy_resource_v3.RuntimeType:  make(map[string]string),
	}
	return &SnapshotHandler{
		resources:      parseResources(resources),
		FieldLogger:    logger,
		changes:        make(map[string]change),
		nonceToVersion: nonceToVersion,
	}
}

func (s *SnapshotHandler) AddSnapshotter(snap Snapshotter) {
	s.snapLock.Lock()
	defer s.snapLock.Unlock()

	s.snapshotters = append(s.snapshotters, snap)
}

// Refresh is called when the EndpointsTranslator updates values
// in its cache.
func (s *SnapshotHandler) Refresh() {
	s.generateNewSnapshot(nil)
}

// OnChange is called when the DAG is rebuilt and a new snapshot is needed.
func (s *SnapshotHandler) OnChange(root *dag.DAG, op dag.CacheOp) {
	s.generateNewSnapshot(op)
}

// Since we don't generate the nonce ourselves, it is generated by go-control-plane
// so we use this to associate the nonce with the snapshot version we are sending.
func (s *SnapshotHandler) SaveNonceToSnapshot(typeURL, nonce, version string) {
	s.opLock.Lock()
	defer s.opLock.Unlock()
	s.nonceToVersion[typeURL][nonce] = version
}

// nonce so we can get what snapshot version to revert
func (s *SnapshotHandler) RevertChange(typeURL, nonce string) {
	s.opLock.Lock()
	defer s.opLock.Unlock()

	version := s.nonceToVersion[typeURL][nonce]

	change := s.changes[version]

	s.WithField("version", version).WithField("nonce", nonce).WithField("type_url", typeURL).WithField("op", change.op).Info("reverting change")

	switch op := change.op.(type) {
	case *dag.OpAdd:
		s.EventHandler.OnDelete(op.Obj)
	case *dag.OpUpdate:
		s.EventHandler.OnUpdate(op.NewObj, op.OldObj)
	case *dag.OpDelete:
		// do nothing? this should not be possible
	case *dag.OpNoop:
		// do nothing? this should not be possible
	}
}

// nonce so we can get what snapshot version change/object to write status for
func (s *SnapshotHandler) AcceptChange(typeURL, nonce string) {
	s.opLock.Lock()
	defer s.opLock.Unlock()

	version := s.nonceToVersion[typeURL][nonce]

	_, ok := s.changes[version]
	if !ok {
		return
	}
	s.changes[version].acks[typeURL] = true

	s.WithField("version", version).WithField("nonce", nonce).WithField("type_url", typeURL).Info("accepting change")

	var ackCount int
	for _, accepted := range s.changes[version].acks {
		if accepted {
			ackCount++
		}
	}
	if ackCount == len(s.changes[version].acks) {
		s.Info("all types acked, can set status to ready")
	}
}

// generateNewSnapshot creates a new snapshot against
// the Contour XDS caches.
func (s *SnapshotHandler) generateNewSnapshot(op dag.CacheOp) {
	// Generate new snapshot version.
	version := s.newSnapshotVersion()

	// Convert caches to envoy xDS Resources.
	resources := map[envoy_resource_v3.Type][]envoy_types.Resource{
		envoy_resource_v3.EndpointType: asResources(s.resources[envoy_resource_v3.EndpointType].Contents()),
		envoy_resource_v3.ClusterType:  asResources(s.resources[envoy_resource_v3.ClusterType].Contents()),
		envoy_resource_v3.RouteType:    asResources(s.resources[envoy_resource_v3.RouteType].Contents()),
		envoy_resource_v3.ListenerType: asResources(s.resources[envoy_resource_v3.ListenerType].Contents()),
		envoy_resource_v3.SecretType:   asResources(s.resources[envoy_resource_v3.SecretType].Contents()),
		envoy_resource_v3.RuntimeType:  asResources(s.resources[envoy_resource_v3.RuntimeType].Contents()),
	}

	if op != nil {
		c := change{
			op:   op,
			acks: make(map[string]bool),
		}
		for t, resList := range resources {
			if len(resList) > 0 {
				c.acks[t] = false
			}
		}
		s.opLock.Lock()
		s.changes[version] = c
		s.opLock.Unlock()
	}

	s.snapLock.Lock()
	defer s.snapLock.Unlock()

	for _, snap := range s.snapshotters {
		if err := snap.Generate(version, resources); err != nil {
			s.Errorf("failed to generate snapshot version %q: %s", version, err)
		}
	}
}

// newSnapshotVersion increments the current snapshotVersion
// and returns as a string.
func (s *SnapshotHandler) newSnapshotVersion() string {

	// Reset the snapshotVersion if it ever hits max size.
	if s.snapshotVersion == math.MaxInt64 {
		s.snapshotVersion = 0
	}

	// Increment the snapshot version & return as string.
	s.snapshotVersion++
	return strconv.FormatInt(s.snapshotVersion, 10)
}

// asResources casts the given slice of values (that implement the envoy_types.Resource
// interface) to a slice of envoy_types.Resource. If the length of the slice is 0, it
// returns nil.
func asResources(messages interface{}) []envoy_types.Resource {
	v := reflect.ValueOf(messages)
	if v.Len() == 0 {
		return nil
	}

	protos := make([]envoy_types.Resource, v.Len())

	for i := range protos {
		protos[i] = v.Index(i).Interface().(envoy_types.Resource)
	}

	return protos
}

// parseResources converts an []ResourceCache to a map[envoy_types.ResponseType]ResourceCache
// for faster indexing when creating new snapshots.
func parseResources(resources []ResourceCache) map[envoy_resource_v3.Type]ResourceCache {
	resourceMap := make(map[envoy_resource_v3.Type]ResourceCache, len(resources))

	for _, r := range resources {
		resourceMap[r.TypeURL()] = r
	}
	return resourceMap
}
